#+TITLE: Rust and Software Development Languages
#+DATE: 2020-07-26
#+AUTHOR: Colin

The past two months have been a pure joy of writing Rust full-time. This follows
after two years of writing Haskell full-time, and this post describes the
immediate feelings and discoveries I had upon switching.

If you have been curious about trying Rust, I highly recommend it. Just think:

- C-speeds.
- No exceptions.
- No ~null~.
- Automatic memory management *without a garbage collector*.
- A practical, balanced amount of FP semantics.

As both a professional developer and a FOSS contributor, I consider Rust to be
the highest quality Software Development Language I've ever used. Does that mean
I think the /language itself/ is necessarily "the best"? Am I just a fanboy? It
isn't so black-and-white, as we'll see, and I think the distinction is an
important one.

* Expanding the Concept of "Programming Language"

What is a Software Development Language and how is that different from a
"Programming Language"?

When talking about a language, we could say that it's fast or slow, concise or
verbose, mangled or pretty, beginner-friendly or plagued by a steep learning
curve. We could comment about how Language A does ~for~ loops /this way/,
Language B does them /that way/, and Language C doesn't have them at all. But
from the perspective of real-world Software Development, these point are nearly
irrelevant.

Let's define a few terms to see why.

** Definition: Programming

#+begin_quote
Programming is the manipulation of Ideas, followed by the encoding of that
manipulation into a physical form (usually code) to be executed on a Computer.
#+end_quote

For some broad definition of /Idea/ and /Computer/. With this, the following are
all programming:

TODO Get links to real projects!

- Writing a two-line Bash script to rename some files.
- Writing a Python function to generate a plot for a Data Science class.
- Editing some CSS to alter your website's layout.
- Typing an SQL query into a database prompt.
- Solving a [[https://projecteuler.net/][coding challenge]].
- Refactoring a module to use newer idioms, reducing code by half.
- Writing a patch in C for the Linux Kernel to support a USB device.
- Writing an algorithm prototype with an associated academic paper.

And so would these be:

- Producing punch cards in the 1970s that solve a physics problem.
- Writing pseudocode of a sorting algorithm on a final exam.
- Linking visual logic blocks together to cause a fun game effect.
- Establishing "forms" with associated validation rules on a Salesforce-based
  data management system.
- The main mechanic of the game [[http://www.zachtronics.com/spacechem/][SpaceChem]].
- That loom thing from a long time ago.

In this sense, the act of programming itself is available to everyone.

** Definition: Software Development

On the other hand, we have /Software Development/:

#+begin_quote
Software Development is the act of Programming followed by Testing, Releasing,
and Maintenance.
#+end_quote

With this, the following are Software Development activities:

- Accepting a bug ticket at work, finding the problem, and submitting a PR for the solution.
- Creating and uploading a personal website.
- Developing and launching a [[https://apps.apple.com/us/app/bubble-level-for-iphone/id465613917][phone app to help level]] a framed picture.
- Producing a AAA sports game for a major gaming console.
- Evaluating and merging patches to the Linux Kernel.
- Patching and deploying the assembly code a 50 year old satellite that has left the solar system.

All languages can be measured on a scale of how sharp a tool they are for the
entire Four Pillared process of Software Development, not just programming.
Particularly sharp languages have solid answers to these real concerns:

- Programming:
  - Do my ideas flow into the editor, or do the language idioms get in my way?
  - Is my day-to-day experience a productive dialogue with the compiler?
  - How many characters must I type to express my intent?
  - Is the language [[https://www.destroyallsoftware.com/talks/wat][filled with GOTCHAs]]?
  - How short are compilation / typecheck times?
  - How beautiful is the syntax I look at every day?
- Testing:
  - How efficiently can I discover if my code is incorrect?
  - Does the language itself provide correctness guarantees that avoid the need for test writing?
  - Am I protected from future changes breaking old code?
  - Can I generate test cases or is everything hand-written?
  - Are benchmarking and profiling first-class activities?
  - How long is CI turnaround?
- Releasing:
  - Is documentation "first class"? Are generated docs well-organized and easy to navigate?
  - Is it obvious how to release a library, and where to discover other ones?
  - Are dependencies a source of strength or liability?
  - Is it straight-forward to produce an optimized release binary?
  - Are strange runtime flags necessary for sane, this-should-be-the-default program behaviour?
- Maintenance:
  - Will code I write today be compilable in a year?
  - How likely am I to understand my own code a year from now? What about others?
  - Can I refactor with confidence?
  - Should I expect frequent runtime crashes?
  - If I don't update my dependencies and compiler often, how soon with the ecosystem "leave me behind"?

Notice that raw executable performance and ease of learning didn't make the
list. Now, /of course/ there are domains where performance is critical. And /of
course/ a language should always provide resources for learning. It's my view in
general, however, that placing these factors above all others is a confusion of
priorities. How much time would you invest learning a new language ecosystem, in
order to become 100% more efficient at the entire software development process?
Especially at maintenance. Part of the ease of learning is familiarity, and one
way to make your language easy to learn is to make it maximally similar to
languages that people already know. Yet if every new thing we encounter is
already familiar, are we really growing?

With all this in mind, what sense is there really in debating the syntax of a
~for~ loop? Or in writing the 1000th /FooLang vs BarLang/ article? Or ranking
the Top 100 Languages?

Give me a language that lets me create, share my creations, and keep my
creations alive. Both Haskell and Rust do a pretty good job of that, and we can
now move on to view Rust through the lens of a Software Development Language.

* Rust for Software Development

Rust is a fantastic language for Software Development. Not because it has or
doesn't have Feature X, but because *it enables me to efficiently write and
maintain software*.

** Programming

*** How is the moment-by-moment programming experience?

No need to frequently recompile: ~cargo check~ (see also [[https://crates.io/crates/cargo-watch][cargo-watch]]) tells me
immediately where and why my code is incorrect. Error messages are clear,
well-formatted, and even provide Error Codes that you can query the compiler for
to obtain elaborate explanations of the cause of the error.

*** What language idioms are available?

Rust could be called a Post-OOP language (like Golang), in that we're returning
to fundamentals. We have structs, enums, functions, loops, and variables.
Mutability is available, but is always explicit and not the default. There are
no Classes to be seen, but the concept of the Method was accepted and is quite
useful for code organization. Exceptions were left out, as was the concept of
~null~. Well wait, how do we model errors then?

Rust also paid attention to what the Functional Languages have been doing over
the past decades. So enums can hold inner values (aka "Sums of Products" or
"ADTs"), we have Pattern Matching, and we have Traits (which can be
auto-derived!). Errors are handled explicitly with the ~Option~ and ~Result~
types. Further, we can do a kind of "error threading" with the ~?~ operator,
which I believe is a wonderful distillation of the Lesson of Monads. Rust is
primarily strict, but accepts the Lesson of Laziness in the form of chainable
Iterators.

Finally, Rust adds the new concepts of Ownership and Borrowing, which allow for
its GC-less automatic memory management.

*** Is it verbose? Is it alright to look at?

You tell me:

#+begin_src rust
  /// Try to extract a position from the `Mess` as a nice integer, as if it
  /// were a [`SemVer`](struct.SemVer.html).
  pub fn nth(&self, x: usize) -> Option<u32> {
      let i = self.chunk.get(x)?;
      let (i, n) = parsers::unsigned(i).ok()?;
      match i {
          "" => Some(n),
          _ => None,
      }
  }
#+end_src

~rustfmt~ makes all code layout standard, so say goodbye to style arguments.

** Testing

*** How does the language protect me from myself?

Strong types and no ~null~. Thanks to Rust's Ownership system, the pitfalls of
pointer and memory management in C are long gone. Yes there is technically ~IO~
everywhere, but once again Ownership makes this hard to abuse. Special ~IO~ and
~STM~ Monads aren't necessary here.

*** How do I test internal functions that aren't exposed to my public API?

Tests go in the file of the functions they're testing. You can also add tests to
your docstrings inside a markdown ~```~ block, and ~cargo~ will detect and run
these. This way, your code samples can never drift out of date.

*** What if I only want to rerun a single troublesome test?

It's very easy to filter tests or mark them as "ignored".

*** What is the CI situation?

Github's default Rust Action will have your project built and tested within a
few minutes, even without a cache of dependencies. There's even an Action to
[[https://github.com/peaceiris/actions-mdbook][automatically publish Rust Books]].

** Releasing

*** Where and how are Rust projects published?

Rust projects are called "crates" and are uploaded to [[https://crates.io/][crates.io]]. Publishing one
is as easy as running ~cargo publish~. Uploading a new version is the same
command. Buggy versions can also be "yanked" off the registry to avoid
accidental usage.

*** How is software versioned?

[[https://semver.org/][Semantic Versioning]] is enforced, and all Rust tooling assumes it. You can even
publish prerelease versions which will appears on a Crate's page if you look,
but they won't become the default for anyone doing casual dependency updates.

*** How do I document a project?

Rust docstrings are markdown and [[https://docs.rs/kanji/1.0.1/kanji/][render quite nicely]]. As mentioned above, code
samples in a docstring found within a ~```~ block will be ran as a test, and
there is no extra configuration necessary to enable this.

*** How do I explore a dependency?

All published libraries have docs [[https://docs.rs/nom/5.1.2/nom/][automatically generated for them]]. You can also
open your project's documentation (with all dependencies too!) locally with
~cargo doc --open~. From there, you can search for any type or function name.

*** Can a single old dependency hold the whole ecosystem back?

No, actually. If two of your dependencies require different versions of the same
transitive dependency, both will be brought into your binary. In practice this isn't
a real problem because:

- Binaries optimize to a fairly small size anyway.
- There are enough keeners in the community to detect these mismatches and
  update them. [[https://github.com/kbknapp/cargo-outdated][Tooling is also available]] for detection.

*** How do I produce an optimized release binary?

~cargo build --release~. This will recompile all dependencies and activate
optimizations. Add the following to your ~Cargo.toml~ to reduce binary size and
further improve performance:

#+begin_src toml
  [profile.release]
  lto = true
#+end_src

You can also run ~strip~ on the final binary to further reduce binary size. Here
are the final binary sizes of the simplest possible "Hello, World!" compiled in
Haskell, Rust, and Go:

| Haskell (stripped) | Rust (stripped) | Go (stripped) |
|--------------------+-----------------+---------------|
| 2.7mb (695kb)      | 1.1mb (219kb)   | 2.0mb (1.4mb) |

And since Rust has no runtime like Go or Haskell, there are no mysterious flags
to pass to your executable to have it perform sanely.

*** How do I develop and release Rust on Windows?

Rust has full Windows support, and all buildtool commands are the same.

** Maintenance

*** How much of a threat is bitrot? Will the ecosystem leave me behind?

Thanks to Semver, code that compiled once should always compile, since
compatible versions of dependencies would always be fetched.

*** How does code stay readable?

Because of good namespacing, all symbols and function names can be given
clear, logical names without the need for mangling to insure uniqueness.

~rustfmt~ output is optimized for clean diffs! This helps the review process.

*** How do I get rid of code I don't need?

Dead code analysis is stronger than Haskell's and is a first-class feature in
the compiler.

*** How do I get access to experimental compiler versions?

Rust has a [[https://doc.rust-lang.org/stable/book/appendix-07-nightly-rust.html][very frequent release cycle]], and it's easy to switch back and forth
between the ~stable~ and ~nightly~ streams. You can even set this per-project so
that ~cargo~ knows what to do automatically as you transition between projects.

* Conclusion

I try not to "fanboy" when it comes to languages. As someone who creates
software, I have a set of needs. If those needs are met, I like the language. If
I discover that another language meets them better, I move on.

Rust is a serious tool for Software Development, and not because of its language
features, its performance, or how it looks. It's the entire package, and I
haven't yet found anything missing.

* Appendix

** Extra Notes for Haskellers

- NumericUnderscores by default.
- Unfortunately there's no ~GeneralizedNewtypeDeriving~.
- Being able to pass ownership solves the problem that Haskell's Linear Types
  were aiming at.
- Impossible to write orphan instances.
- Generics are monomorphized, meaning there's no runtime penalty for using them!
- Rust knows how to pretty-print things be default.
